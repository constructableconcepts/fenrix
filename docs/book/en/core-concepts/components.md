# The Component Model

Components are the fundamental building blocks of a Fenrix application. They are reusable, self-contained pieces of UI that can be composed to create complex user interfaces.

## Creating a Component

In Fenrix, a component is simply a Rust function marked with the `#[component]` attribute. This function returns a `web_sys::Node`, which is typically generated by the `rsx!` macro.

Here is an example of a simple component:

```rust
use fenrix_macros::{component, rsx};

/// A simple, static component.
#[allow(non_snake_case)]
#[component]
fn App() -> web_sys::Node {
    rsx! {
        <div>
            <h1>"Simple Component"</h1>
            <p>"This is rendered from a Fenrix component."</p>
        </div>
    }
}
```

Key points:
- The `#[component]` attribute transforms the function into a component that can be used within the `rsx!` macro.
- By convention, component names are written in `PascalCase`. The `#[allow(non_snake_case)]` attribute is used to suppress the compiler warning for the function name.
- The component returns a `web_sys::Node`, which represents a piece of the DOM that Fenrix will manage.

## Rendering a Component

To use a component, you can render it from within another component or at the root of your application using the `rsx!` macro. The syntax is similar to using a custom HTML tag:

```rust
use fenrix_dom::render;
use fenrix_macros::{component, rsx};
use wasm_bindgen::prelude::*;

// ... (App component definition from above)

/// The entry point for the application.
#[wasm_bindgen(start)]
pub fn run() {
    // The rsx! macro understands how to render components.
    let app_instance = rsx! { <App /> };

    // Render the component instance to the DOM.
    render(app_instance);
}
```

In this example, `<App />` is not an HTML tag; it's a call to render the `App` component we defined earlier. Fenrix's `rsx!` macro processes this syntax at compile time, wiring up the component to be rendered in the correct place.

This component-based architecture allows you to break down your application into small, manageable pieces, making your code easier to read, test, and maintain.